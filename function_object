
仿函数：函数对象，重载了operator()的class

/*=========================================================	
Chapter I  			仿函数的意义
=========================================================*/

满足STL对抽象性的需求，与其他STL组件搭配 —— 函数指针虽然也能当做算法参数，但是无法和其他STL组件搭配


/*=========================================================	
Chapter II  		可配接的关键
=========================================================*/

仿函数 应该有能力被 函数配接器（function adapter）修饰
	为了拥有配接能力，每一个仿函数 “ 必须定义自己的相应型别 ”，这些型别是为了让配接器能够取出，获得仿函数的某些信息。
	相应型别只是一些 typedef ，对程序的执行效率没有任何影响
	
STL定义了 一元仿函数 和 二元仿函数 ，其中没有 data members 或 member function，唯有一些型别定义。
	任何仿函数，只要按需继承了其中一个 class，便自动拥有了那些相应型别，也就自动拥有了配接能力
	
	

1、unary_function

unary_function 用来呈现一元函数的参数型别和回返值型别

//这里用的是struct，默认是public
	template <class Arg, class Result>
	struct unary_function{
		typedef Arg argument_type;
		typedef Result result_type;
	};

//举例
	//一元仿函数
	template <class T>
	struct negate : public unary_function<T, T>{
		T operator() (const T& x) const { return -x; }
	};

	//配接器 —— 模板类型是一个仿函数
	//配接器实际上配接的就是方法的形参列表
	template <class Predicate>
	class unary_negate{
		...
		public:
			bool operator() (const typename Predicate::argument_type &x) const { ... }
	};
	



2、binary_function

binary_function 用来呈现二元函数的第一参数型别、第二参数型别，以及回返值型别

//定义
	template <class Arg1, class Arg2, class Result>
	struct binary_function {
		typedef Arg1 first_argument_type;
		typedef Arg2 second_argument_type;
		typedef Result result_type;
	};
