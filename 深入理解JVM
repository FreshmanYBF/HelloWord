
自动内存管理机制
	Java内存区域与内存溢出
		运行时数据区域
			程序计数器，栈/本地栈，堆，方法区，运行时常量，直接内存
		HotSpot虚拟机对象内存布局
		内存溢出异常
	垃圾收集器与内存分配策略
		对象死亡判定
		垃圾收集算法
		垃圾收集器
		内存分配与回收策略
调试与调优
	虚拟机性能监控与故障处理工具
		JDK命令行工具：jps，jstat，jinfo，jmap，jhat，jstack，HSDIS
		JDK可视化工具：JConsole，VisualVM
	调优案例分析与实战
		案例分析
			高性能硬件上的程序部署策略
			集群间同步导致的内存溢出
			堆外内存导致的溢出错误
			外部命令导致系统缓慢
			服务器JVM进程崩溃
			不恰当数据结构导致内存占用过大
			由Windows虚拟内存导致的长时间停顿
		调优实战
			Eclipse运行速度调优
虚拟机执行子系统
	类文件结构
		Class类文件的结构
		字节码指令
		公有设计和私有实现
		Class文件结构的发展
	虚拟机类加载机制
		类加载的时机
		类加载的过程
		类加载器
	虚拟机字节码执行引擎
		运行时栈帧
		方法调用
		基于栈的字节码解释执行引擎
	类加载及执行子系统的案例与实战
		案例分析
			Tomcat：正统的类加载器架构
			OSGi：灵活的类加载器架构
			字节码生成技术与动态代理的实现
			Retrotranslator：跨越JDK版本
		实战
			自己动手实现远程执行功能
程序编译与代码优化
	早期(编译期)优化
		javac编译器
			解析，符号表，语义分析，字节码生成
		java语法糖的味道
			泛型，类型擦除，自动装箱、拆箱，遍历循环，条件编译
		实战：插入式注解处理器
	晚期(运行期)优化
		HotSpot虚拟机内的即时编译器
		编译优化技术
		Java与C/C++的编译器对比	
高并发
	Java内存模型与线程
	线程安全与锁优化
	

附录：
	虚拟机字节码指令表
	HotSpot虚拟机主要参数表
	对象查询语言


Java与C++相比最突出的特点就是 —— 内存自动管理
=================================
内存管理
=================================
	内存划分
		运行时数据区域
			程序计数器：每个线程一个独立的程序计数器
			虚拟机栈
				每个方法在执行的同时创建一个栈帧
					栈帧：方法名，方法入参，方法局部变量，方法返回值/返回地址
					局部变量所需的内存在编译期分配
						基本数据类型，对象引用，返回地址类型
				StackOverflowError —— 线程请求的栈深度大于虚拟机所允许的深度，或者内存不足时
			本地方法栈
				虚拟机执行Native方法
			Java堆
				被所有线程共享；虚拟机启动时创建；存放对象实例及数组；垃圾回收的主要区域
				OutOfMemoryError —— 堆中没有内存时
			方法区
				存储已经虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码数据(即时编译器将常用的指令编译成本地机器指令)
			运行时常量池
				方法区的一部分
			直接内存
				NIO类，通过Java堆中的DirectByteBuffer对象直接引用Native中的内存

	HotSpot虚拟机对象内存布局
		对象创建
			new -> 检查常量池中类的符号引用 -> 该类是否被加载、解析和初始化过? -> 没有则加载 -> 加载完成，确定内存 -> 从Java堆中分配对象内存 -> 初始化内存0值
			
		对象内存布局
			对象头 + 实例数据 + 对齐填充
				对象头
					存放对象自身的运行时数据：哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳
					类型指针：对象指向它的类元数据的指针 —— 感觉是Class对象
				实例数据
					对象真正存储的有效信息
				对齐填充
		
		对象访问
			通过栈中的reference(引用)来访问堆中的对象。reference实现方式有句柄和直接指针
				句柄
					Java堆中划分出一块内存作为句柄池，句柄中包含了对象实例数据与类型数据各自的具体地址信息
						当对象移动(垃圾收集)时，只需要更改句柄池中句柄中的对象地址
				直接指针
					reference中存储的是对象地址
						快，但是对象移动时要更改所有栈中的引用
	
	垃圾收集器
		回收算法
			什么时候回收？ —— 对象死了
				引用计数算法
					给对象添加一个引用计数器。引用为0的需要回收。
					缺点：无法解决对象之间的相互循环引用问题
				可达性分析算法
					从GC Roots开始向下搜索，对象不可达的，需要回收。
						GC Roots：虚拟机栈/方法区中的类静态属性引用的对象/方法区中常量引用的对象；本地方法栈中JNI引用的对象
					对象不可达
						放入F-Queue队列中
						执行finalize()方法 —— finalize()方法只会被系统自动调用一次
							finalize()方法中可以进行自救
				引用
					强引用：只要强引用还存在，GC永远不会回收掉被引用的对象
					软引用：还有用但并非必需的对象。在发生内存溢出异常之前，进行第二次回收
					弱引用：描述非必需对象。GC发生时即被回收
					虚引用：用于对象被收集器回收时收到一个系统通知。
	
			回收方法区
				回收废弃常量和无用的类
			
			垃圾收集算法
				标记-清除算法
					标记需要回收的对象，回收所有标记的对象
					缺点：存在内存碎片
				复制算法
					将可用内存分为大小相等的两块。一块用完，将还存活的对象复制到另一块
					缺点：内存利用率不高
					商业实现
						BM公司按照8:1:1划分空间 —— 一个Eden和两个Survivor
							回收时，将Eden和Survivor中还存货的对象一次性复制到另外一块Survivor空间上
							清理掉Eden和用过的Survivor空间
				标记-整理算法
					标记，移动活的对象都一端，清除掉另一端
				分代收集算法
					根据对象存活周期的不同将内存划分为几块
						新生代
							每次垃圾收集时都会有大批对象死去，只有少量存货，选用复制算法
						老年代
							对象存活率高，没有额外空间对它进行分配担保，使用“标记-清理”或“标记-整理”算法来进行回收
					
	
	内存分配与回收策略
		在堆上分配内存，具体的分配规则与收集器有关
		但是有几条最普遍的内存分配规则
		1、对象优先在Eden分配
		
		2、大对象直接进入老年代
			大对象：大量连续内存空间的Java对象
		3、长期存活的对象将进入老年代
			对于经历了一次Minor GC后仍然存活的对象，对象年龄设置为1
			当年龄增加到一定程度，就晋升为老年代
		4、动态对象年龄判定
			如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代
		5、空间分配担保
			确保空间足够完成复制算法


			
=================================
虚拟机性能监控与故障处理工具
=================================
	给一个系统定位问题，知识、经验是关键基础，数据是依据，工具是运用知识处理数据的手段
		数据：运行日志、异常堆栈、GC日志、线程快照、堆转储快照
	
	JDK命令行工具
		1、jps：虚拟机进程状况工具
			JVM Process Status Tool
			列出正在运行的虚拟机进程，并显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一ID
		2、jstat：虚拟机统计信息监视工具
			JVM Statistics Monitoring Tool
			显示本地或远程虚拟机进程中类装载、内存、垃圾收集、JIT编译等运行数据
		3、jinfo：Java配置信息工具
			实时查看和调整虚拟机各项参数
		4、jmap：Java内存映像工具
			生成堆转储快照
		5、jhat：虚拟机堆转储快照分析工具
			分析jmap生成的堆转储快照
		6、jstack：Java堆栈跟踪工具
			生成虚拟机当前时刻的线程快照
		7、	HSDIS：JIT生成代码反汇编
		
	JDK的可视化工具
		JConsole：Java监视与管理控制台
			jconsole.exe
		VisualVM：多合一故障处理工具
			运行监视和故障处理
				显示虚拟机进程以及进程的配置、环境信息
				监视应用程序的CPU、GC、堆、方法区以及线程的信息
				dump以及分析堆转储快照
				方法级的程序运行性能分析，找出被调用最多、运行时间最长的方法
				离线程序快照




				
=================================				
虚拟机执行子系统
=================================		

字节码，机器码

类文件结构
	Class文件本质是一种文件格式，可以以任何形式存在，是组8位字节为基础的单位的二进制流
	
		Class文件格式
			类型				名称					数量
			u4					magic					1
			u2					minor_version			1
			u2					major_version			1
			u2					constant_pool_count		1
			cp_info				constant_pool			constant_pool_count - 1
			u2					access_flags			1
			u2 					this_class				1
			u2					super_class				1
			u2					interfaces_count		1
			u2					interfaces				interfaces_count
			u2 					fields_count			1
			filed_info			fields					fields_count
			u2					methods_count 			1
			method_info			methods					methods_count
			u2 					attributes_count 		1
			attribute_info		attributes				attributes_count
			
		（1）magic与version
			magic的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件
				很多文件存储标准中都使用魔数进行身份识别，而不是文件扩展名(扩展名可以随意改动)，这是为了安全
		（2）constant_pool 
			常量池，可以理解为Class文件之中的资源仓库，是占据Class文件空间最大的数据项目之一
				constant_pool_count的计数值从1开始而不是0，如果值为0X0016，即十进制22，那么常量池中有21项常量
			常量池主要存放两大类常量
				字面量
					比较接近Java语言层面的常量概念，如文本字符串、声明为final的常量值等
				符号引用
					属于编译原理方面的概念
					包括下面三类常量
						类和接口的全限定名(Fully Qualified Name)
						字段的名称和描述符
						方法的名称和描述符
		（3）访问标志
			用于识别一些类或者接口层次的访问信息
				是否为public，ACC_PUBLIC
				是否定义为abstract，ACC_ABSTRACT
				是否被声明为final
		（4）类索引、父类索引与接口索引集合
			Class文件中由这三项数据来确定这个类的继承关系
				java类都是单继承，除了java.lang.Object外，所有Java类的父类索引都不为0
				接口索引集合就用来描述这个类实现了哪些接口，这些接口按序排列在接口索引集合中
		（5）字段表集合
			描述接口或类中声明的变量。包括类级变量以及实例级变量，但是不包括方法内部声明的局部变量
		（6）方法表集合
			Class文件存储格式对方法的描述与对字段的描述几乎采用了完全一致的方式
			方法里的Java代码，经过编译器编译成了字节码指令后，存放在方法属性表集合中一个名为“Code”的属性里面
		（7）属性表集合
			任何实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不认识的属性
				Code属性
					方法体中的代码经过javac编译器处理后，变为字节码指令存储在Code属性内
						Code属性表结构
							u2				attribute_name_index				1
							u4				attribute_length					1
							u2				max_stack							1
							u2				max_locals							1
							u4				code_length							1 
							u1				code								code_length
							u2				exception_table_length				1
							exception_info	exception_table						exception_table_length
							u2 				attributes_count 					1
							attribute_info	attributes							attributes_count
						max_stack代表操作数栈深度的最大值
						max_locals代表局部变量表所需的存储空间
							max_locals的单位是Slot，Slot是虚拟机为局部变量分配内存所使用的最小单位
							对于byte、char、float、int、short、boolean和returnAddress等长度不超过32位的数据类型，每个局部变量占用1个Slot
							这些slot可以复用
						code用来存储字节码指令
				Exception属性
					列举出方法中可能抛出的受查异常，也就是方法描述时在throws关键字后面列举的异常

	字节码指令
		Java虚拟机指令由		一个字节长度的操作码 + 0至多个操作数			构成
		
		Java虚拟机采用 “面向操作数栈” 而不是寄存器的架构，大多数指令都不包含操作数，只有一个操作码
			
		字节码指令集 —— 短小精干，高效传输
			只有一个字节，操作码总数不可能超过256
			Class文件格式没有使用操作数长度对齐
				所以操作码后面就跟着操作数字节流
				在进行数据操作时，需要把这些字节流转成对应的数据类型
				
		1、字节码与数据类型	
			int，long，short，byte，char，float，double，reference
			iload，加载int型数据到操作数栈
				imul, isub,i add, idiv, ior, ixor等
			fload，加载float型数据到操作数栈
			
		2、加载和存储指令
			加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输
			
		3、运算指令
			对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶
			
		4、类型转换指令
			将两种不同的数值类型进行相互转换
		
		5、对象创建和访问指令
			对象创建
				new
				newarray
			访问指令
				getfield
				putfield
				getstatic
				putstatic
			加载数组元素
				baload、caload、saload、iaload
			操作数栈的值存储到数组元素
				bastore、castore、sastore、iastore
		6、操作数栈管理指令
			出栈：pop、pop2
			复制栈顶：dup、dup2
			栈顶两个值互换：swap
		7、控制转移指令
			条件分支：
				ifeq、iflt、ifle、ifnull ...
			复合条件分支
				tableswitch、lookupswitch
			无条件分支
				goto、goto_w、jsr、jsr_w
		8、方法调用和返回指令
			invokevirtual —— 调用对象的实例方法
			invokeinterface —— 调用接口方法
			invokespecial —— 调用一些需要特殊处理的实例方法
			invokedynamic —— 运行时动态解析出调用点限定符所引用的方法，并执行该方法
			
			ireturn、lreturn、freturn、dreturn、areturn
		9、异常处理指令
			java虚拟机中，处理异常不是由字节码指令来实现，而是采用异常表来完成
		10、同步指令
			Java虚拟机支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是用管程来支持的
				java虚拟机的指令集有monitorenter和monitorexit两条指令来支持synchronized关键字
				
	
	公有设计和私有实现
		虚拟机规范 是 公有设计，描述了Class文件格式以及字节码指令集。
		在实现虚拟机的过程中，可以生成自己的优化
		
		虚拟机实现方式主要有两种：
			将输入的Java虚拟机代码在加载或执行时翻译成另外一种虚拟机的指令集
			将输入的Java虚拟机代码在加载或执行时翻译成宿主机CPU的本地指令集(即JIT代码生成技术) —— just in time

			
			

虚拟机类加载机制 —— 运行期间加载 和 动态链接
	
	加载(Loading) -> 验证(Verification) -> 准备(Preparation) -> 解析(Resolution) -> 初始化(Initialization) -> 使用(Using) -> 卸载(Unloading)
		连接：验证，准备，解析
		加载 -> 验证 -> 准备 -> 初始化 -> 卸载，这5个阶段的顺序是确定的
	
	类加载的时机	
		加载->验证->准备->解析->初始化->使用->卸载
		有且仅有的5种必须对类进行“初始化”的情况
			（1）遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有初始化过，则需要先触发初始化
			（2）使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有初始化过，则需要先触发初始化
			（3）当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化
			（4）当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个类
			（5）当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应类没有进行过初始化，则需要先触发其初始化
			
		接口的初始化
			编译器会为接口生成"<clinit>()"类构造器，用于初始化接口中所定义的成员变量
			接口与类真正有所区别是第（3）种：接口初始化时，并不要求其父类接口全部都完成初始化，只有使用到父类接口时才会初始化
			
	类的加载过程
		加载
			加载阶段，虚拟机需要完成以下3件事情
			（1）通过一个类的全限定名来获取定义此类的二进制字节流
			（2）将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构
			（3）在内存种生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口
		
			自定义类加载器去控制字节流的获取方式 —— 从网络/从文件/从接口 
	
			数组类的加载 —— 和普通类加载有所不同
				数据类本身不通过类加载器创建，而是由Java虚拟机直接创建的
				一个数组类的创建过程遵循一下规则：
					（1）数组的组件类型是引用类型，就递归采用本节定义的加载过程去加载这个组件类型，数组将在加载该组件类型的类加载器的类名称空间上被标识
					（2）数组的组件类型不是引用类型(int[])，Java虚拟机将会把数组标识为与引导类加载器关联
					（3）数组类的可见性与它组件类型的可见性一致，如果组件不是引用类型，那么数组类默认为public
		
		验证
			验证是连接阶段的第一步，目的是确保Class文件的字节流符合当前虚拟机的要求
			（1）文件格式验证 —— 魔数：0xCAFEBABE
			（2）元数据验证 —— 是否有父类；父类是否继承了不允许被继承的父类；是不是抽象类
			（3）字节码验证 —— 程序语义是否合法
			（4）符号引用验证 —— 符号引用转成直接引用
		
		准备
			正式为类变量分配内存并设置类变量(java.lang.Class和static变量)初始值(一般0，可以内存占位，常量则为具体的值)，
				这些变量所使用的内存都将在方法区中进行分配
		
		解析
			虚拟机将常量池内的符号引用替换为直接引用的过程
				符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量
				直接引用：可以直接指目标的指针、相对偏移量或一个能间接定位到目标的句柄
			解析根据指令的不同可以发生在加载阶段，即程序还未执行(静态解析)，也可以发生在运行阶段，即执行到这条指令时(动态调用)
			
		初始化
			<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的
				虚拟机会保证<clinit>()方法执行时的互斥性
				
	类加载器
		实现类的加载动作 —— 类的唯一性是由 <类加载器, 类本身> 唯一确定的，即同一个类文件被不同加载器加载，那么不认为这是相同的类
		
		双亲委派模型
			Bootstrap ClassLoader：启动类加载器，加载<JAVA_HOME>\lib目录或-Xbootclasspath指定的路径下文件
			Extension ClassLoader：扩展类加载器，加载<JAVA_HOME>\lib\ext目录或java.ext.dirs指定的路径
			Application ClassLoader：应用程序类加载器，加载ClassPath路径文件
		
			




			
	
虚拟机字节码执行引擎	
	执行引擎：解释执行 和 编译执行(编译器产生本地代码执行)
	
	运行时栈帧
		栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息
			在编译代码的时候，栈帧需要多大的局部变量表，多深的操作数栈都已经完全确定，并放在方法表的Code属性中
			一个线程中，方法的调用链可能会很长，由很多栈帧，但是对于执行引擎来说，只有位于栈顶的栈帧才是当前执行的栈帧
		（1）局部变量表
			存放方法参数和方法内部定义的局部变量
			为了节省栈帧空间，局部变量表中的Slot可以重用 —— 当字节码PC计数器的值超过了某个变量的作用域时，这个变量对应的Slot就可以交给其他变量使用了
		（2）操作数栈
		（3）动态连接
			每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接
			Class文件的常量池中存在大量的符号引用
				这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用
				另一部分将在每一次运行期间转换为直接引用 —— 动态连接
		（4）方法返回地址
	

	
		方法调用
			方法调用不等同于方法执行
				方法调用是确定被调用方法的版本，暂时还不涉及方法内部的具体运行过程
			
			（1）解析
				编译期可知，运行期不变的方法的调用 —— 静态方法和私有方法
			（2）分派 —— 重载和重写
				重载是静态分派，取决于参数的静态类型
				静态分派
					方法的调用取决于传入的参数的数量和数据类型(静态类型，而不是实际类型)
					所有依赖静态类型来定位方法版本的分派动作称为静态分派
					静态分派发生在编译阶段
			（3）动态分派
				动态分派与重写(Override)密切关联
				invokevirtual指令的多态查找过程
					找到操作数栈顶的第一个元素所指向的对象的实际类型
					如果在类型中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；
						如果不通过，则返回java.lang.IllegalAccessError异常
					否则，按照继承关系从下往上一次对类型的各个父类进行上一步的搜索和验证过程
					如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常
			（4）虚拟机动态分派的实现
				在类方法区中建立一个虚方法表(Virtual Method Table)，使用虚方法表索引来代替元数据查找以提高性能
				方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的方法表也初始化完毕
		
		动态类型语言支持
			类型检查的主体过程是在运行期而不是编译器
			java.lang.invoke包
				使用MethodHandle来确定目标方法
				MethodHandle在模拟字节码层次的方法调用，而Reflection在模拟Java代码层次的方法调用
				
	
	基于栈的字节码解释执行引擎 —— 虚拟机如何执行方法中的字节码指令
		
		编译过程
			程序源码 -> 词法分析 -> 单词流 -> 语法分析
												  |
			解释执行 <- 解释器 <- 指令流 <-   抽象语法树
												  |
			目标代码 <- 生成器 <- 中间代码 <- 优化器
	
		基于栈的指令集和基于寄存器的指令集
			基于栈的指令集
				Java编译器输出的指令流，基本上是一种基于栈的指令集架构
					指令流中大部分都是零地址指令
					它们依赖操作数栈进行工作
				基于栈的指令集主要优点：可移植，代码更加紧凑，编译器实现更加简单
								  缺点：执行速度相对稍微慢
		
		
		

		
		
		

=================================				
程序编译与代码优化
=================================
概述

	静态AOT编译器：直接把*.java文件编译成本地机器代码

	早期(编译期)优化 —— 前端编译器：把*.java文件转为*.class文件的过程
		javac编译器
		java语法
			泛型，类型擦除，自动装箱、拆箱，遍历循环，条件编译
	晚期(运行期优化) —— 后端编译器(JIT编译器)：把字节码转成机器码的过程
		HotSpot虚拟机内的即时编译器
		编译优化技术
		Java与C/C++的编译器对比
	
编译期优化
	Javac编译器 —— 由java语言编写
		解析和填充符号表
			1、词法、语法分析
				词法分析 
					将源代码的字符流转变为标记集合
						标记包括：关键字、变量名、字面量、运算符等
				语法分析
					根据标记序列构造抽象语法树的过程
						语法树的每一个节点都代表程序代码中的一个语法结构，例如包、类型、修饰符、运算符、接口、返回值设置代码注释等都可以是一个语法结构
					
			2、填充符号表
				符号表是由一组符号地址和符号信息构成的表格
					符号表中所登记的信息在编译的不同阶段都要用到
					符号表所登记的内容将用于语义检查和产生中间代码。在目标代码生成阶段，当对符号名进行地址分配时，符号表时地址分配的一句
					
		注解处理器 —— Annotation
			注解与普通的Java代码一样，是在运行期间发挥作用的
			JDK 1.6中提供了一组插入式注解处理器的标准API在编译期间对注解进行处理，可以把它看作是一组编译器插件，在插件里，可以读取、修改、添加抽象语法树中的任意元素
			
		语义分析与字节码生成
			语义分析的主要任务是对结构上正确的源程序进行上下文有关性质的审查
				语法树能标识一个结构正确的源程序的抽象，但无法保证源程序是符合逻辑的
				比如 int a = 3; boolean b = false; char c = 2; int d = a+c; int d = b+c; char d = a+c; 这些赋值运算符合语法分析，但是某些在Java语义中是不合法的
			1、标注检查
				变量使用前是否声明
				变量与赋值之间的数据类型是否匹配
				常量折叠 —— 对常量运算在编译期计算结果
			
			2、数据及控制流分析
				对程序上下文逻辑更进一步的验证
					比如程序局部变量在使用前是否赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理等问题
			
			3、解语法糖(Syntactic Sugar)
				糖衣语法：指在计算机语言中添加的某种语法，这种语法对语言功能并没有影响，但是更方便程序员使用
				把泛型、变长参数、自动装箱/拆箱等还原成简单的基础语法结构就是解语法糖
			
			4、字节码生成
				

	Java语法糖 
		泛型与类型擦除
			Java语言中的泛型在编译后，字节码文件中就已经替换为原来的原生类型了，并且在相应的地方插入了强制转型代码
				对于运行期的Java语言来说，ArrayList<int>与ArrayList<String>就是同一个类
				Java语言中的泛型实现方法称为 “类型擦除”，基于这种方法实现的泛型称为伪泛型
		
		自动装箱、拆箱与遍历循环
			遍历循环需要被遍历的类实现Iterable接口
			自动装箱：自动将基本数据类型转换为封装类型
			自动拆箱：自动将封装类型转换为基本数据类型
			
		条件编译 —— 使用条件为常量的if语句
			根据布尔常量值的真假，编译器会把分支中不成立的代码块消除掉



运行期优化
	何时使用解释器？何时使用编译器？哪些代码会被编译成本地代码？如何编译为本地代码？
	HotSpot虚拟机内的即时编译器
		HotSpot解释器与编译器并存，存在两个不同的即时编译器
			即时编译：把代码编译成本地平台相关的机器码，并进行各种层次的优化
	
		解释器与编译器
			需要迅速启动和执行时，解释器可以首先发挥作用，省去编译时间，立即执行
			随着时间推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获得更高的执行效率
			
			当内存限制较大时，可以使用解释执行节约内存
			
		HostSpot虚拟机内置了两个即时编译器，分别称为Client Compile和Server Compiler
			虚拟机会根据主机硬件性能自动选择运行模式，也可以使用"-client"或"-server"参数指定模式
			可以使用"-Xint"强制虚拟机运行在“解释模式”，也可使用"-Xcomp"强制虚拟机运行在“编译模式”
		
		分层编译
			根据编译器编译、优化的规模与耗时，划分出不同的编译层次
			第0层：解释执行
			第1层：C1编译，将字节码编译为本地代码，进行简单、可靠的优化
			第2层：C2编译，将字节码编译为本地代码，但是会启动一些编译耗时较长的优化，甚至会根据性能监控信息采取激进优化
	
		编译对象与触发条件
			“热点代码”：多次调用的方法；多次执行的循环体
			“Hot Spot Detection(热点探测)”
				基于采样的热点探测：周期性检查各个线程的栈顶，如果发现某个方法经常出现在栈顶，就是“热点方法”
				基于计数器的热点探测：为每个方法(设置代码块)建立计数器，统计方法的执行次数，查过某个阈值就认为是“热点方法”
			
			HotSpot采用计数器热点探测：方法调用计数器和回边计数器
				-XX: CompileThreshold 可以设置方法调用计数器的阈值
				-XX: -UseCounterDecay可以关闭热度衰减
				-XX: CounterHalfLifeTime可以设置半衰周期的时间，单位是秒
				-XX: BackEdgeThreshold可以设置回边计数器的阈值
				-XX: OnStackReplacePercentage来间接设置回边计数器的阈值
		
		编译过程
			-XX：-BackgroundCompiliation来禁止后台编译
			Client Compiler是一个简单快速的三段式编译器，主要关注点在局部性的优化
				第一阶段：将字节码构成一种高级中间代码表示
				第二阶段：高级中间代码产生低级中间代码表示
				第三阶段：线性扫描算法在低级中间代码上分配寄存器，并做窥孔优化，然后产生机器代码
			Server Compiler专门面向服务端的编译器
				可以执行 无用代码消除，循环展开，循环表达式外提，消除公共子表达式，常量传播，基本块重排序等
				
		编译优化技术
			公共子表达式消除
			数组边界检查消除
			方法内联
			逃逸分析
			
		
Java与C/C++的编译器对比
	即时编译器与静态编译器的对比
	
	Java虚拟机即时编译器与C/C++静态优化编译器的劣势
		（1）即时编译占用的是用户程序的运行时间
		（2）Java语言是动态的类型安全语言，需要由虚拟机来确保程序不会违反语言语义或访问非结构化内存
		（3）Java没有virtual关键字，但是使用虚方法的频率远远大于C/C++语言，即时编译器在进行一些优化时难度远大于C/C++静态优化编译
		（4）Java是动态扩展的语言，运行时加载新的类可能改变程序类型的继承关系，很多全局优化都很难进行
		（5）Java中对象的内存分配都是在堆上进行的，而C/C++对象可以在栈中，可以在堆上，减轻了内存回收压力
	Java开发效率超高
	
	






=================================				
高效并发
=================================	
	
	
Java内存模型与线程
	硬件效率与一致性
	内存模型
	线程

线程安全与锁优化
	线程安全
	锁优化



Java内存模型与线程
	衡量一个服务器性能的高低，每条事务处理数
	
	硬件效率与一致性
		高速缓存
		多处理器，当每个处理器共享内存的高速缓存数据不一致时，如何同步？
			为了解决一致性问题，缓存回写时都会遵循一些协议：MSI，MESI，MOSI，Synapse，Firefly，Dragon Protocol等
		
	Java内存模型
		Java内存模型的主要目标是：定义程序中各个变量的访问规则，即虚拟机中将变量存储到内存和从内存取出变量这样的底层细节
			此处的变量包括：实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是栈私有的，不被共享，不存在竞争问题
		
		Java内存模型规则所有的变量都存储在主内存中
			每条线程有自己的工作内存，工作内存存放了主内副本拷贝
			线程间变量的传递均需要通过主内存来完成
		
		内存间交互操作
			一个变量如何从主内存拷贝到工作内存，如何从工作内存同步回主内存
			
		volatile型变量的特殊规则
			volatile可以说是Java虚拟机提供的最轻量级的同步机制
			volatile变量具备两种特性
				保证此变量对所有线程的可见性 —— 当一个线程修改了这个变量的值，新值对其他线程是可以立即得知的
				禁止指令重排
		
	Java与线程
		线程的实现
			Thread类所有关键方法都声明为Native的，Native方法都是和平台强相关的
		线程实现方式
			内核线程实现：一个内核线程对应一个用户线程
			用户线程实现：一个内核线程对用多个用户线程
			用户线程加轻量级进程混合实现：多个内核线程对应多个用户线程
		线程调度
			协同式线程调度：线程执行时间由线程本身控制，主动通知系统切换到另一个线程
			抢占式线程调度：每个线程由系统分配执行时间
		线程状态
			新建，就绪，运行，结束，阻塞
	
	

	

线程安全与锁优化
	线程安全
		java语言中各种操作共享的数据可以分为5类
			不可变
			绝对线程安全：synchronized
			相对线程安全：Vector，HashTable，Collections的synchronizedCollection()方法包装的集合等。一些特定顺序的连续调用可能需要额外的同步手段保证正确性
			线程兼容：对象本身不是线程安全的，可以同通过调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用
			线程对立：无法并发使用的代码
		线程安全的实现方法
			互斥同步
			非阻塞同步
			锁
				ReentrantLock(重入锁)
				公平锁
		锁优化
			适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁
