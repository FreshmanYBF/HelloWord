从Linux内核学习设计

	单内核
		内核以单个静态二进制文件的存放与磁盘
		所有内核服务都在这样的一个大内核地址空间运行
		
	微内核
		功能被划分为多个独立的过程
		每个过程叫做一个服务器
		
		
		
		
		
		强烈要求特权服务的服务器才运行在特权模式下
		通过”消息传递“处理微内核通信 —— 系统采用了进程间通信机制(IPC)
		
		实际应用的基于微内核的系统都让大部分或全部服务器位于内核
			这样可以直接调用函数，消除频繁的上下文切换
			
		
	Linux
		单内核
		模块化设计、抢占式内核、支持内核线程以及动态装载内核模块的能力

		
		

内核源码获取和编译
	http://www.kernel.org
	
	git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6.git
	
	git pull //更新到最新分支
	
	内核源码一般安装在 /usr/src/linux 目录下，C库所用的内核版本就链接到这颗树
	
	所以新的源码安装在自己的主目录下
		patch -p1 < ../patch-x.y.z
		
	编译选项
		yes —— 把代码编译进主内核映像中
		no
		module —— 以模块形式(独立代码段)存在

	内核源码树目录下的.config文件保存了linux的模块编译选项
	
	make -jn  //衍生多个作业编译
	
	
内核开发的特点

	内核编程时既不能访问C库，也不能访问标准的C头文件
	内核编程时必须使用GUN C
	内核编程时缺乏像用户空间那样的内存保护机制
		oops
		内核中的内存都不分页，没用掉一个字节，物理内存就减少一个字节 —— 内核不会被分出去，而是常驻内存
	内核编程时难以执行浮点运算
		内核中使用浮点数，除了要人工保存和恢复浮点寄存器，还要做一些其他琐碎的事情，非特殊情况，不要使用
	内核给每个进程只有很小的定长堆栈
		内核栈的准确大小随体系结构而改变
		一般是两页大小 —— 32位机上是8KB，64位机上是16KB
	由于内核支持异步中断、抢占和SMP，必须时刻注意同步和并发
		内核的许多特性都要求能够并发地访问数据
			Linux是抢占多任务操作系统
			Linux内核支持对称多处理器系统
			中断是异步到来的
			Linux内核可以抢占
	要考虑可移植性的重要性
		诸如保持字节序，64位对齐、不假定字长和页面长度等一系列准则
	
	C库太大，且太低效！！！！！
	
	
	GNU C
		GNU C标准，GNU C对ANSI C标准增加了一些扩展特性
		gcc是多种GNU编译器集合，他包含的C编译器既可以编译内核，也可以编译Linux系统上用C语言写的其他代码
		
		1、内联函数
		inline
		2、内联汇编
		gcc编译器支持C函数中嵌入汇编指令
			内核编程时，只有知道对应的体系结构，才能使用这个功能
			通常使用asm()指令嵌入汇编代码
		3、分支声明
		对于条件语句可以使用likely()和unlikely()，对条件分支进行优化
		被包含的条件表明了一种分支选中的频率
