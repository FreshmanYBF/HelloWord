整本书总分为两部分：
	生成可执行文件 —— 文件的组成，格式
	执行可执行文件 —— 文件的装载，动态库的链接
	

======================================================
						简介
======================================================

Hello World
#include <stdio.h>
int main()
{
	printf("Hello World\n");
	return 0;
}

（1）程序为什么编译后才能运行？

（2）C被编译器成可执行的机器码的过程中做了什么？怎么做的？

（3）最后编译出来的可执行文件里面是什么？除了机器码还有什么？它们是怎么存放的，怎么组织的？

（4）#include <stdio.h>是什么意思？包含进来意味着什么？C语言库又是什么？它怎么实现的？

（5）不同的编译器和不同的硬件平台以及不同的操作系统，最终编译出来的结果一样吗？为什么？

（6）Hello World程序是怎么运行起来的？操作系统是怎么装载它的？它从哪儿开始执行，到哪儿结束？main函数之前发生了什么？结束后又发生了什么？

（7）如果没有操作系统，Hello World可以运行吗？在没有操作系统的机器上运行Hello World需要什么？应该怎么实现？

（8）printf是怎么实现的？它为什么可以有不定数量的参数？为什么能够在终端上输出字符串？

（9）Hello World程序在运行时，它在内存是什么样子的？


符号的解释 
程序的开始
程序的执行 
程序的结束

=============================
	从器件频率来看结构变迁
=============================

CPU，内存，IO控制芯片 —— 外设的速度相对于内存和CPU慢很多，为了协调它们之间的速度

1、CPU频率 = 内存频率

					  I/O设备				  I/O设备
						|						|
   CPU	  Memory	 I/O controller			I/O controller
	|		|			|						|			
	|		|			|						|
==================================================  总线

2、CPU频率 > 内存

与内存频率一致的通过系统总线通信
CPU采用倍频的方式与系统总线通信

3、其他高速设备的引入 —— 南桥芯片 与 北桥芯片

图形芯片需要跟CPU和内存大量交换数据，慢速的I/O总线无法满足需求

为了协调CPU、内存和高速的图形设备，人们专门设计了一个高速的 北桥芯片，以便它们能够高速地交换数据

北桥运行速度非常高，相对低速的设备如果全部连接到北桥上，其设计就会非常复杂

南桥芯片，专门处理低速设备

低速设备上采用ISA总线，与南桥连接；高速设备上采用PCI总线，与北桥连接

=================================
	对称多处理器 和 多核处理器
=================================

对称多处理(SMP) —— 原生多核
	CPU内部必须内置APIC(Advanced Programmable Interrupt Controller)单元，即高级可编程中断控制器
		CPU通过彼此发送中断来完成它们之间的通信
		通过给中断附加动作，不同的CPU可以在某种程度上彼此进行控制
		如果从GPU来看，把每个独立的动作分解为每个点，把一个任务看作在从某个点到另一个点的路径
			把这些路径分配给不同的核执行 —— 这是自己的猜想
		
多核处理器 —— 封装多核，将多个核心直接封装在一起
	共用同一个前端总线
	
多核CPU编程 —— 并发处理架构
	参考文献：《基于多核CPU的雷达信号并发处理架构设计》 杨思军
		如何实现多核CPU的并发处理能力？ —— 参考图形处理器(GPU)的设计和处理模式
			CPU的设计是针对大量离散而不相关的任务的系统
			GPU是处理那些可以分成成千上万个小块并独立运行的问题
		1、线程池加速技术 —— 活动线程总数不超过核的两倍
			创建线程池
		2、并发编程
			共享资源的竞争
		
Harmony OS是如何实现多核编程的
	HarmonyOS是否使用了云计算
	
==================================
	计算机软件体系结构
==================================
		
	App		Development Tools(Compiler, Assember, Library Tools)
	-------------------------
		Runtime Library
	-------------------------
	 Operating System Kernel
	-------------------------
		    Hardware

1、系统调用接口 —— 以软中断的昂是提供，Linux以0x80号中断作为系统调用接口，Windows使用0x2E号中断做为系统调用接口

2、硬件接口定义决定了驱动程序如何操作硬件，如何与硬件进行通信 —— 这种接口往往被叫做硬件规格
		比如扫码器，写入一些控制指令，扫码器就有对应的动作
		

===============================
	充分发挥硬件的能力
===============================

CPU，存储器，I/O设备

操作系统运行在一个受硬件保护的级别

1、CPU不间断工作

使用调用器，定时器，中断来实现
	定时器引发一个中断来触发调用器执行，调度某个进程进行执行
		使用中断实现调度器的定时执行和进程的抢占，使用调度器实现进程的调度

2、硬件驱动程序

操作系统为硬件生产厂商提供了一些列 接口和框架
	按照这个接口和框架开发的驱动程序都可以在该操作系统上使用
	

3、内存管理 —— 虚拟地址，分页(程序局部性原理)

从物理地址到虚拟地址的改进——地址隔离，从分段到分页的改进——内存利用率

	程序给出的地址看作虚拟地址，通过某些映射方法转成实际的物理地址
	
	局部性原理：运行的某个时间段内，频繁地用到了一小部分书，多数都不会被使用
		如何知道哪些程序是局部性的，是常驻内存的？
		
	分页：把地址空间人为地等分成固定大小的页，每一页的大小由硬件决定（硬件可支持多种大小的页），操作系统选择使用哪种大小的页
		虚拟页：虚拟空间的页
		物理页：物理空间的页
		磁盘页：磁盘上的页
			把虚拟页映射到同一个物理页上就实现了内存共享
			操作系统是如何评估哪些数据和代码页是常用的？是编译器编译的时候就确立的吗？
		页的权限属性：操作系统优先权设置页的权限数据，做到保护自己和保护进程
	
	MMU：Memory Management Unit，实现虚拟地址的硬件
		接收CPU发送过来的虚拟地址，将其转成物理地址，存取物理地址中数据，执行物理地址中的指令
		
4、线程

	线程间共享进程资源，独享自己的栈空间，PC，寄存器
	线程的切换由操作系统控制
	线程的优先级
		用户指定
		操作系统根据器进入等待状态的频繁程度较低或提升(I/O密集型线程和CPU密集型线程)
		长时间得不到执行而被操作系统提升优先级
	抢占和不可抢占
		抢占：时间片用完，进入就绪
		不可抢占：线程试图等待某个事件或主动放弃时间片时才会让出CPU，时间片用完并不影响
		
	Linux的多线程
		Linux将所有的执行实体都称为任务
			每个任务都类似于一个单线程的进程
		fork，exec，clone
			fork产生本任务的镜像，并与原任务一起共享”写时复制“的内存空间
			exec用新的可执行映像替换当前的可执行映像
				fork和exec一起使用，便可以在一个进程中产生另一个进程
			clone产生一个新的任务，从指定位置开始执行，并共享当前进程的内存空间和文件
		
	线程安全
		信号量，互斥量(可跨进程)，临界区(进程内)，读写锁(以共享方式获取所/以独占方式获取锁)，条件变量
		过度优化
			（1）寄存器优化。为了提高速度将变量存入寄存器，而不同线程的寄存器是独立的。使用volatile
			（2）CPU乱序执行。调用CPU提供的一条指令，通常称为barrier(栅栏)，栅栏阻止之前的指令被换到barrier之后执行
			
	多线程模型
		线程的并发执行都是由多处理器或操作系统调度来实现的
		一般来说用户实际使用的线程是用户线程，并不是内核线程
		（1）一对一模型
			一个用户线程对应一个内核线程
			一般直接使用API或系统调用创建的线程均为一对一模型
		（2）多对一模型
			多个用户线程映射到一个内核线程上
				当其中一个阻塞，则其他用户线程也阻塞
		（3）多对多模型
			多个用户线程映射到多个内核线程上
				—— 这个有点像线程池的概念
				   用户可能生成了100多个线程，但是线程池中只有20个线程
						但是这个的20个线程在实际过程中依旧存在用户态切换到内核态的花销
	
	

======================================================
						编译和链接
======================================================
	被隐藏的过程
	编译器做了什么
	链接器年龄比编译器长
	模块拼接——静态链接

1、被隐藏的过程
	
预处理，编译，汇编，链接


（1）预处理
	处理源代码文件中以“#”开始的预编译指令
		保留所有 #pragma 编译器指令，因为编译器要使用它们
		添加行号和文件名标识
	
（2）编译
	词法分析
	语法分析
	语义分析
	优化
	
GCC把预编译和编译合并成一个步骤，使用一个叫做ccl的程序来完成这个步骤
GCC就是很多后台程序的包装 —— 预编译编译程序ccl，汇编器as，链接器ld

（3）汇编
	根据汇编指令和机器指令的对照表进行翻译就行
	
（4）链接
	将众多的目标文件链接起来 —— 对于符号是从每个链接文件的首部中的符号表去查找吗？
	虚拟地址是在什么时候分配的？哪一个数据处于哪一个地址的位置是在何时定下来的？


2、编译器做了什么

编译过程
	词法分析 —— 扫码源码，获取所有独立的“词”
		Scanner -> Tokens(标志)
		对于变成语言里面
	语法分析
		Parser -> Syntax Tree
	语义分析
		Commented Syntax Tree
	源代码优化
		Source Code Optimizer
	代码生成
		Code Generator
	目标代码优化
		Code Optimizer
	

（1）词法分析
利用有限状态机的算法
将源码中的所有字符序列分割成一系列的记号(Tokens)
	词法分析产生的记号一般可以分为如下几类：关键字、标识符、字面量和特殊符号。
		标识符放在符号表中，字面量存放在文字表中
		
（2）语法分析
对扫描器产生的记号进行语法分析，从而产生语法树
	分析过程采用 上下文无关语法 和 下推自动机
语法树就是以表达式为节点的树，C语言的一个语句是一个表达式

（3）语义分析
语法分析只是完成了对表达式的语法层面的分析
	它并不了解这个语句是否真正有意义
语义分析是静态语义分析，即编译器可以确定的含义——包括声明和类型的匹配，类型的转换
	对语法树中的节点进行类型标识
	
（4）中间语言生成
源代码优化器 —— 将语法树转成中间代码，中间代码与目标机器和运行时环境无关
中间代码使得编译器可以分为前端和后端
	前端：生成中间代码
	后端：将中间代码转成目标机器代码
	
（5）目标艾玛生成与优化
代码生成器：将中间代码转成转换成目标机代码。
	这个过程十分依赖于目标机器 —— 不同机器有不同的字长，寄存器，整数数据类型和浮点数数据类型

目标代码优化器：对目标代码进行优化。
	选择合适的寻址方式，使用位移来代替乘法运算，删除多余指令等

（6）链接—— 地址何时确定
扫描(词法分析)->语法分析->语义分析->中间代码生成(源代码优化)->目标代码生成->目标代码优化 
	经过这些步骤后，变量的地址还没确定
对于位于其他模块的变量，链接器将这些源代码编译成的目标文件链接起来，确定绝对地址
早期的汇编语言演变来的一个概念 —— 符号表示一个地址
模块间符号的引用

链接过程包括：地址和空间分配、符号决议和重定位
	地址和空间分配
	符号决议：应该链接到哪个符号
	重定位：编译成目标文件时，对于不知道的目标地址，设置为0，等待编译器修正。
			每个要被修正的地方叫一个重定位入口。
	



======================================================
					目标文件里有什么
======================================================
目标文件的格式
目标文件是什么样的
挖掘SimpleSection.o
ELF文件结构描述
链接的接口 —— 符号
调试信息


1、目标文件格式

Windows下是PE(Protable Executable)，Linux下是ELF(Executable Linkable Format)，都是COFF(Common File Format)的变种
	COFF在目标文件中引入“段”的机制

可执行文件涵盖了程序的编译、链接、装载和执行的各个方面，了解它的结构有助于认识系统

目标文件是编译后但未进行链接的中间文件，跟可执行文件的内容与结构很相似

动态库和静态库都是按照可执行文件格式存储

（1）ELF文件标准把系统中ELF格式文件分为4类
	可重定位文件：包含了代码和数据，可以被用来链接成可执行文件或共享目标文件，Linux的.o和Windows的.obj
	可执行文件：ELF可执行文件。
	共享目标文件：包含了代码和数据。链接器使用其与其他文件链接，产生新的目标文件；动态链接器，将其与可执行文件结合，映射到进程中运行
	核心转出文件(Core Dump File)：当进程意外终止时，系统可以将进程的地址空间内容及终止时的其他一些信息转储到核心转储文件
	

2、目标文件是什么样

目标文件有指令代码、数据
	由于还要链接，所以还有符号表，字符串等信息
	
一般目标文件将这些信息按不同的属性，以“节”(Section)的形式存储，有时也叫“段”(Segment)
	Code Segment：
		代码段，常见名字有 .text，.code 
	Data Section: 
		数据段

（1）格式 —— 文件头 + 各个段

	文件头：
		描述整个文件的文件属性，包括文件是否可执行、是静态链接还是动态链接及入口地址、目标硬件、目标操作系统等
		文件头还包括一个段表，段表描述文件中各个段在文件中的偏移位置及段的属性等
		重定位表：记录需要重定位的代码段和数据段
		字符串表：存放段名，变量名等
	段：
		.bss段：记录所有未初始化的全局变量和局部静变量的大小综合
		.text段：代码段，程序指令段
		.data段：数据段
	
	程序编译后主要分成两部分 —— 指令 + 数据
		指令和数据分开的好处
			程序装载后，数据和指令分别被映射到两个虚存区域。指令只读，数据可写，对两个续存区域设置权限可以防止代码被改写
			为了有效利用CPU的缓存体系，指令和数据分离有利于提高程序的局部性
			当系统中运行着程序的多个副本时，内存中只需要保存一份该程序的指令部分

3、链接的接口 —— 符号

（1）符号 —— 符号，特殊符号，符号修饰(避免不同模块同名冲突)
	链接中，将函数和变量统称为符号，函数名或变量名就是符号名，符号值就是它们的地址
	ELF文件中的符号表往往是文件中的一个段 —— .symtab

	extern "C" ：C++为了兼容C，在符号的管理上，C++使用这个声明或定义一个C的符号
				  C++编译器会把 extern "C" 的大括号内部的代码当作C语言代码处理

	__cpluscplus：C++编译器会在编译C++程序时，默认定义这个宏
					可以使用条件宏来判断当前编译单元是不是C++代码 


（2）弱符号与强符号






	



