
/*=========================================================	
Chapter I  			URL与资源
=========================================================*/

URL语法由9部分组成：
	<scheme>://<user>:<password>@<host>:<port>/<path>;<param>?<query>#<frag>
		
		param(参数)和query(查询条件)使用Key=Value形式表示，KV之间使用&连接
		frag(片段)：标识一个字段中的某个片段, 表示只想获取片段。
					但是服务器只会响应整个对象，而不会只响应片段，所以frag用于客户端，客户端从整个响应对象中摘取出片段显示出来
					
1、相对URL

在HTML中可以使用相对URL来表示资源，相对URL为保持一组资源的可移植性可提供了一种便捷方式 

	有了 “ 基础URL ” 才能对 “ 相对URL ” 进行转换
	
2、自动扩展URL
用户输入的时候尝试自动扩展URL，这样用户无需输入完整的URL

（1）主机名扩展
（2）历史扩展。将历史访问的URL存储起来


3、URL的字符组成规则

URL应该是可移植的(可用于各种不同的协议，而有些协议会剥离一些特殊字符)，可供人阅读的(不能由不可见，不能打印的字符)，完整的(转义机制将不安全的字符编码为安全字符)

（1）URL通用字母表和编码规则

URL字符集：ASCII
	问题：有些特殊字符，二进制数据无法使用ASCII满足完整性的同时表示出来
	解决方法：转义序列。通过转义序列，使用ASCII字符集对任意字符值或数据进行编码。
	编码机制：通过一种 “转义” 表示法来表示不安全的字符
			  转义表示法：一个百分号(%)后面跟两个表示字符ASCII码的十六进制数   例如，空格，ASCII为32(0x20)，则表示为%20
			  
（2）字符限制
一些字符不在定义的ASCII可打印字符集中，有些字符与某些因特网网关和协议产生混淆

/*=========================================================	
Chapter II  		  HTTP报文
=========================================================*/

起始行
首部 ( 会给出一些与实体有关的信息, 例如Content-Type, Content-Length )
报文实体

1、CRLF
每行以回车换行符结束——回车符 ASCII码13，换行符 ASCII码10
	但是有的使用单个换行符作为终止，应用程序也应该能够解析
由于历史原因，很多在没有实体的主体部分时，省略最后的CRLF，虽然这是不符合规范的，但是应用程序应该接受(历史遗留问题)。

2、状态码
（1）100~199	信息提示
100 Continue			C端需要在Except首部中指定
	C端Except首部携带100 Continue，等待接收到S端的100 Continue，收到它就会继续发送实体，但如果超时仍然未收到，则也要发送实体
	S端如果在没有响应100 Continue前，就收到实体。那么它应该继续接受实体，然后返回最终的响应
101 Switch Protocols 	C端需要在Update中指定
	S端正在将协议切换成C端Update首部所列的协议 
（2）200~299 成功

（3）300~399 重定向
S端响应首部中Location字段会指出重定向资源的URL

（4）400~499 客户端错误
405 Method Not Allowed
406 Not Acceptable			C端说明可以接受什么类型的实体，S端不匹配的话则返回
408 Request Timeout		
412 Precondition Failed		C端发起了条件请求，且其中一个条件失败时使用了。C端使用Except首部发起条件请求
417 Exception Failed 		请求的Expect请求首部包含一个期望，但服务器无法满足此期望时，使用此状态码

（5）500~599 服务端错误

3、首部
（1）通用首部——请求和响应中均可用
Trailer				如果报文采用了分块传输编码(chunked transfer encoding)方式，可以用该字段列出位于报文拖挂部分的首部集合
Transfer-Encoding	对报文采用什么编码方式
Update				想要“升级”使用的新版本或协议
Via 				显示报文经过的中间节点（代理、网关）
（2）请求首部
Client-IP			C端IP地址
From				客户端用户的E-mail地址
Referer				提供了包含当前请求URI的文档的URL
User-Agent			将发起请求的应用程序名称告诉S端

Accept				C端的喜好和能力，告知S端。Accept 媒体类型；Accept-Charset 字符集；Accept-Encoding 编码方式；Accept-Language 语言

Except				条件请求首部，C端为请求加上某些限制。If-Match 匹配标记；If-Modified-Since 指定某个日期后资源被修改过则响应该请求；If-None-Match 标记不匹配
														 If-Range 对文档某个范围进行请求；If-Unmodified-Since 从某个日期开始，资源从未被修改过
														 Range	范围请求

Authorization		认证
Cookie				客户端用它向服务器传送一个令牌——它并不是真正的安全首部，但确实隐含了安全功能
Cookie2				说明请求端支持的cookie版本
	
（3）响应首部
Age					响应持续时间
Retry-After			如果资源不可用，在此日期或时间重试

Accept-Range 		S端可接受的范围类型

Set-Cookie			不是真正的安全首部，但隐含有安全功能；可以在C端设置一个令牌，一遍服务器对C端进行标识

（4）实体首部——描述主体的长度和内容，或资源自身
Allow 				可以对实体执行的请求方法
Location			实际URL

Content-Base
Content-Encoding
Content-Language
Content-Location
Content-MD5			主体的MD5校验和
Content-Range		在整个资源中实体表示的字节范围

ETag 				与此实体相关的实体标记
Expires 	`		实体不再有效，要从原始的源端再次获取此实体的日期和时间
Last-Modified 		这个实体最后一次修改的日期和时间

（5）扩展首部
首部可以分为多行，多出来的每行前面至少要有一个空格或制表符

4、方法
GET
HEAD：响应报文只返回首部
PUT
POST：通常用来支持表单
TRACE：请求可能穿过防火墙、代理、网关或其他一些应用程序，TRACE可以看到最后一战是否修改了原始报文。
OPTIONS：请求Web服务器告知其支持的各种功能
DELETE： 

/*=========================================================	
Chapter III  		  TCP连接
=========================================================*/

HTTP连接管理应当从实验与经验中学习

（1）HTTP是如何使用TCP连接的
（2）TCP连接的时延、瓶颈以及存在的障碍
（3）HTTP的优化，包括并行连接、keep-alive（持久连接）和管道化管理
（4）管理连接时应该以及不应该做的事情

 如果要编写复杂的，快速运行的HTTP应用程序，需要学习的与TCP内部原理及性能有关的知识，推荐《TCP/IP》详解
 
 TCP，分组交换，可靠，通过IP分组的小数据块来发送。<Source IP, Destination IP, Source TCP Port, Destination TCP Port>
 
*===============================	
	   对TCP性能的考虑
===============================*/
对TCP性能的考虑

HTTP事务的时延：
	DNS查询，连接，请求，数据处理，响应，关闭
	
1、时延的主要原因
（1）DNS解析。URI中的主机名转换成一个IP可能需要数十秒，但是大多数HTTP客户端都有本地缓存，且主机名都是常用站点，所以通常很快解析
（2）TCP连接建立（三次握手）。SYN同步，SYN+ACK确认，ACK确认
（3）发送请求报文，读取请求报文，处理请求报文，发送响应报文
（4）关闭连接（四次挥手）。可以不用管是否挥手成功。

硬件，网络和服务器的负载，请求和响应报文的尺寸，C与S之间的距离，TCP协议的技术复杂性都会对时延产生影响


2、性能聚焦区域
（1）TCP连接建立握手
C端发送SYN说明这是一个连接，S端响应SYN+ACK，说明连接请求被接受，C端回送ACK表示连接已成功建立

有的时候很多响应报文都可以放入一个IP分组中去，导致小的HTTP事务，在TCP建立上花费50%的时间甚至更多

（2）TCP慢启动拥塞控制

TCP传输的性能还取决于TCP连接的使用期。

	TCP连接会随着时间进行 自我调谐 ，起初会限制连接的最大速度，如果数据传输成功，会随着时间推移提高传输的速度。
		这种调谐成为慢启动，用于防止因特网的突然过载和拥塞。
		
	由于已调谐的连接会更快一下，所以一些新的连接的传输速度通常比已经交换过一些数量的数据慢一些。
		为了重用已经建立的连接，HTTP增加了 ” 持久连接 “


（3）数据聚集的Nagle算法


（4）用于捎带确认的TCP延迟确认算法
每个TCP段都有一个序列号和数据完整性校验和。段被接收后，接收者回送小的确认分组。如果发送者在 ” 指定的窗口时间 “ 内没有收到确认信息，则认为分组丢失或破坏，则重发数据

由于分组很小，确认报文常常与输出的数据分组结合在一起

为了增加确认报文找到同向传输分组的可能性，很多TCP栈都实现了一种 “ 延迟确认 ” 算法。
		延迟确认算法会在一个特定的 “ 窗口时间 ” (通常是100~200ms)内将输出确认存放在缓冲区中，以寻找能够捎带它的输出分组
		如果在那个时间段内没有输出数据分组，就将确认信息放在单独的分组中传送
	
	但是HTTP具有双峰特征的请求-应答行为，降低了捎带信息的可能。当希望有相反方向回传分组时，偏偏没有那么多了。延迟确认算法可能引入相当大的延迟。根据所使用OS不同，可以禁用或调整延迟确认算法。

（5）TIME_WAIT时延和端口耗尽
