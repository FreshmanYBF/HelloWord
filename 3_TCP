
=======================
		 UDP
=======================

|	16位源端口号	|	16位目的端口号	|
|	16位UDP长度		|	16位UDP校验和	|
|				  数据					|

1、校验和
16bit二进制反码和
不够16bit的在尾部补0计算 —— 增补的字节不参与传送
如果计算出来的检验和为全0，则设置校验和为全1
	校验和为全0，则表示UDP没有计算校验和


2、伪首部
放在UDP首部之前
包含IP首部的一些字段 —— 让UDP两次检查数据是否已经正确达到目的地
	源IP地址，目的IP地址

3、IP分片


4、UDP，MTU，ARP


5、UDP服务器设计
C端的设计非常容易，但是S端的设计收到UDP特性的影响

（1）客户端IP地址及端口号
服务器知道了源端IP地址和端口号，知道了对端，才能同事处理多个客户的请求

（2）目的IP地址
将UDP数据报中的目的IP地址交给应用程序
	但是有的程序对于广播地址的数据报进行忽略
	
（3）UDP输入队列
通常程序使用的每个UDP端口都与一个有限大小的输入队列相联系
	当来自多个客户的请求同事达到时，将由UDP自动排队，按照接收顺序交给应用程序
如果队列满了，数据可能会被丢弃

（4）限制本地IP地址
大多数UDP服务器在创建UDP端点时都使其本地IP地址具有通配符的特点
	这就表明进入的 U D P数据报如果其目的地为服务器端口，那么在任何本地接口均可接收到它

（5）限制远端IP地址
大多数系统允许UDP端点对远端地址进行限制
	这说明端点将只能接收特定 I P地址和端口号的UDP数据报

（6）每个端口有多个接收者
多个端点可以使用同一个IP地址和UDP端口号
	比如使用 SO_REUSEADDR 
4.4BSD支持多播传送，需要应用程序设置一个不同的socket选项(SO_REUSEPORT)，
	以允许多个端点共享同一个端口
当UDP数据报到达目的IP地址为广播地址或多播地址，而且目的IP地址和端口号处有多个端点时，就向每个端点传送一份数据报的复制


==========================
	    广播和多播
==========================
单播地址，广播地址，多播地址

广播和多播仅应用于UDP，它们对于需将报文同时传往多个接收者的应用来说十分重要
	广播：主机向网上所有其他主机发送帧
	多播：帧仅发送给属于多播组的多个主机

帧过滤过程：
	网卡查看信道传过来的帧，确定是否接收
		接收则将它传往设备驱动程序
	通常网卡仅接收那些目的地址为网卡物理地址或广播地址的帧
	多数接口均被设置为混合模式，能接收每个帧的一个复制
		tcpdump使用这种模式

多播地址 
	以太网，最高字节的最低位设置为1时，表示该地址是一个多播地址

1、广播 
（1）受限的广播
255.255.255.255
（2）指向网络的广播
指向网络的广播地址是主机号全为1的地址
（3）指向子网的广播地址
指向子网的广播地址是主机号全为1且特定子网号的地址
（4）指向所有子网的广播
指向所有子网的广播地址是子网号及主机号全为1

2、多播
IP多播提供两类服务
	向多个目的地址传送数据
			
	客户对服务器的请求
	
（1）多播地址
	1110  多播组ID
能够接收发往一个特定多播组地址数据的主机集合称为主机组

	224.0.0.1 代表 子网内的所有系统组
	224.0.0.1 代表 子网内的所有路由器组
	
（2）多播组地址到以太网地址的转换
00:00:5e:00:00:00 到 00:00:5e:ff:ff:ff 
	IANA将其中一半分给多播地址
	为了指明一个多播地址，任何一个以太网地址的首字节必须是01
		01:00:5e:00:00:00 到 01:00:5e:7f:ff:ff
	使得以太网多播地址中的23bit与IP多播组号对应起来了
		多播组号中的低23位映射到以太网地址中的低23位
	由于多播组号的最高5bit在映射过程中被忽略，所以每个以太网多播地址对应的多播组不是唯一的
		由于地址映射不是唯一的，设备驱动层或IP层就必须对数据报进行过滤
		
单个物理网络的多播是简单的
	多播进程将目的IP地址指明为多播地址
	设备驱动程序将它转换为相应的以太网地址
	然后把数据发送出去
	接收进程必须通知它们的IP层，它们想接收的发往给定多播地址的数据报，并且设备驱动程序必须能够接收这些多播帧
	一个主机上可能存在多个进程属于同一个多播组 —— 此时接收到的数据复制到每个进程

（3）FDDI和令牌环网络中的多播
FDDI使用相同的D类IP地址到48bit FDDI地址的映射过程
令牌环网络通常使用不同的地址映射方法


==========================
IGMP: Internet组管理协议
===========================

支持主机和路由器进行多播的Internet组管理协议 IGMP 
	ICMP，IGMP都被当作IP层的一部分
	

1、IGMP报文

长度为8字节的IGMP报文格式
	|	版本(4位)	|	类型(4位)	|	未用	|			校验和			|
	|								32位组地址(D类IP地址)					|
	
2、ICMP协议

（1）加入一个多播组
多播的基础是一个进程的概念
	进程在一个主机的给定接口上加入一个多播组
	一个给定接口上的多播组中的成员是动态的
一个主机通过组地址和接口来识别一个多播组
	主机必须保留一个表，此表中至少包含有一个进程的多播组以及多播组中的进程数量

（2）IGMP报告和查询
多播路由器使用IGMP报文来记录与该路由器相连的网络中组成员的变化情况
	当一个(或多个)进程加入一个组时，主机就发送一个IGMP报告。——按组发送
	进程离开一个组时，主机不发送IGMP报告
	多播路由器定时发送IGMP查询(向每个接口发送一个查询) —— IGMP查询报文的组播地址被设置为0
	主机通过发送IGMP报告来响应一个IGMP查询

多播路由器根据查询和报告报文，对每个接口保持一个表
	表中记录接口上至少还包含一个主机的多播组
	当路由器收到要转发的多播数据报时，它只将数据报转发到(使用相应的多播链路层地址)还拥有属于那个组主机的接口上

多播路由器只需要关系该组播组中是否还存在主机 —— 因为是使用组播IP地址和组播以太网地址进行发送的
												具有相同属性的地址主机都会接收到组播报文

（3）生存时间字段
默认情况下，待传多播数据报的TTL被设置为1
	这使得多播数据报仅局限在通过一个子网内传送
	更大的TTL值能被多播路由器转发
一个应用程序可实现对一个特定服务器的扩展环搜索。
	第一个多播数据报以TTL等于1发送，如果没有相应，就尝试将TTL设置为2，然后3
	在这种方式下，该应用能知道以跳数来度量的最近的服务器

（4）所有主机组
路由器的IGMP查询被送到目的IP地址224.0.0.1，该地址被称为所有主机组地址
	它涉及一个物理网络中所有具备多播能力的主机和路由器
	当接口初始化，所有具备多播能力接口上的主机均自动加入这个多播组。这个组的成员无需发送IGMP报告


==========================
		DNS
==========================

域名解析协议：请求域名，响应域名对应的IP

|	标识符			|	标志 				|
|	问题数			|	资源记录数			|
|	授权资源记录数	|	额外资源记录数		|
|				查询问题					|
|				回答（资源记录数可变）		|
|				授权（资源记录数可变）		|
|				额外信息（资源记录数可变）	|

报文由12字节长的首部和4个可变长度字段组成


1、查询问题
	|				查询名字(多字段)	 |
	|		查询类型	|		查询类	 |

（1）查询名字：一个或多个标识符序列。
		  每个标识符以首字节的计数值来说明随后标识符的字节长度
		  每个名字以最后字节为0结束
		  比如，|6|g|e|m|i|n|i|3|t|u|c|4|n|o|a|o|3|e|d|u|0|

（2）查询类型：
	名字			数值		描述
	A				1 			IP地址 
	NS				2 			名字服务器 
	PTR				12 			指针记录
	大约有20个不同的类型值
	
（3）查询类：通常是1，指互联网地址

2、指针查询

给定一个IP地址，返回与该地址对应的域名

3、其他

（1）高速缓存。减少Internet上的DNS通信量
（2）一般使用UDP协议，设计的DNS程序要确保重传和超时机制
（3）当数据分组超过UDP分组大小时，最好使用TCP协议
		即对于DNS的某些功能，如果传输的数据较大，使用TCP协议
		
=============================
	TFTP：简单文件传送协议
=============================

Trivial File Transfer Protocol，简单文件传送协议
	最初用于引导无盘系统
	使用UDP

1、TFTP报文格式

|	IP首部	|	UDP首部	|

|	操作码(2字节)	|	数据	|

（1）操作码 = 1
RRQ，读请求
|	操作码(2字节)	|	文件名(N字节)	|0|	模式(N字节)	|0|
文件名，以1个全0字节结尾
模式，以1个全0字节结尾
（2）操作码 = 2
WRQ，写请求
|	操作码(2字节)	|	文件名(N字节)	|0|	模式(N字节)	|0|
（3）操作码 = 3 
文件数据分组
|	操作码(2字节)	|	块编号(2字节)	|	文件数据	|
（4）操作码 = 4
ACK确认包
|	操作码=4(2)	|	块编号(2字节)		|
（5）操作码 = 5 
|	操作码=5(2)	|	差错码(2字节)		|	差错信息(N字节)	|0|

2、安全性
TFTP用于无盘机的引导系统，常被用于获取Unix口令文件，用于猜测用户口令
为了防止这种问题，TFTP服务器提供了一个选项来限制只能访问特定目录下的文件


=============================
	BOOTP：引导程序协议
=============================

无盘引导系统，通过RARP来获取自己的IP地址
	使用RARP有两个问题：
		（1）IP地址是返回的唯一结果
		（2）RARP使用链路层广播，RARP请求不会被路由器转发，迫使每个实际网络设置一个RARP服务器

BOOTP引导程序协议，用于无盘系统引导系统的新方法

1、BOOTP的分组格式

BOOTP请求和应答均被封装在UDP数据报中

|	IP首部	|	UDP首部	|	BOOTP请求/应答(300字节)	|


|	操作码(1)	|	硬件类型(1)	|	硬件地址长度(1)	|	跳数	|
|							事务标识							|
|			秒数				|			未使用				|
|							客户IP地址							|
|							你的IP地址							|
|							服务器IP地址						|
|							网关IP地址							|
/						 客户主机硬件地址(16字节)				/
/						 服务器主机名(64字节)					/
/						 引导文件名(128字节)					/
/						 特定厂商信息(64字节)					/

（1）操作码
1，表示请求
2，表示应答
（2）硬件类型，硬件地址长度
1，表示以太网，地址长度为6字节
（3）跳数
客户端设置为0
（4）事务标识 
由客户端设置，并由服务器返回的32 bit整数
（5）秒数 
客户开始进行引导时，将“秒数”字段设置为一个时间值。

当一个客户使用BOOTP进行系统引导时，引导请求通常采用链路层广播
	IP首部的目的IP地址时255.255.255.255
	源IP地址通常是0.0.0.0，因为此时客户还不知道它本身的IP地址。系统进行自引导时，0.0.0.0是一个有效的IP地址
	
2、端口号

BOOTP有两个熟知端口：BOOTP服务器67，BOOT客户68

3、BOOTP服务器的设计

BOOTP客户通常固化在无盘系统只读存储器中
BOOPT从它的数值端口(67)读取UDP数据，且必须读取类型字段为“RARP请求”的以太网帧
由于此时客户没有IP地址，无法处理ARP请求

4、BOOT穿越路由器

如果路由器支持BOOTP协议，那么BOOTP能够由路由器转发
	这个功能主要用于无盘路由器
		因为如果在磁盘的都用户系统被用作路由器，它能够自己运行BOOTP服务器
		Unix BOOTP服务器支持中继模式，即用作BOOTP路由器


=============================
	TCP：传输控制协议
=============================		

TCP

建立和终止TCP连接
数据传输过程
超时及重传技术
定时器

1、TCP基本概念

面向连接，可靠的字节流服务
	分片：应用数据被分割成TCP认为最合适发送的数据块 —— MSS
	超时重传：当TCP发出一个段后，它启动一个定时器，等待目的段确认。不能及时收到确认，将重发这个段
	延时确认：TCP收到发自另一端的TCP数据时，它将发送一个确认。这个确认不是立即发送，通常推迟几分之一秒
	校验和：TCP将保持它的首部和数据校验和
	序列号：TCP作为IP数据报来传输，IP数据报的到达可能失序，因此TCP报文段也可能会失序。TCP会对收到的数据进行重排
	重复包丢弃：TCP必须丢弃重复的数据
	流量控制：TCP还能提供流量控制。TCP连接的每一方都有固定大小的缓冲康健。TCP接收端只允许另一端发送接收端缓冲区所能接纳的数据(速度匹配)。
	
字节流和字节流的解释方式 —— 比如解释成UTF8，解释成ASCII，解释成GBK232等，这些都是随应用程序而定

（1）TCP首部

|		源端口号(16)			|		目的端口号(16)		|
|					序号(32)								|
|					确认序号(32)							|
|首部长度|保留位(6)	|U|A|P|R|S|F|		窗口大小(16)		|
|		校验和(16)				|		紧急指针(16)		|
/							选项							/
/							数据							/

端口：确认连接双方
序号：标识数据字节流。表示这个报文端中的第一个数据字节。
		建立连接时，SYN标志变1。序号字段为初始序号(ISN, Initial Sequence Number)
		SYN标志消耗一个序号，FIN标志也要占用一个序号
确认序号：已成功收到的数据字节序号加1
		当没有遇到预想的确认号的包时，接收方会重传该确认号的ACK包
		当收到的确认号的包校验和校验失败时，接收方会重传该确认号的ACK包
首部长度：首部中32bit字的数目。TCP最多有60((15*4=60)字节的首部。
标志位：
	URG	紧急指针
	ACK	确认序号有效
	PSH	接收方应该尽快将这个报文端交给应用层
	RST	重建连接
	SYN	同步序号，用来发起一个连接
	FIN 发端完成发送任务
窗口大小：TCP流量控制。窗口大小位字节数，起始于确认序号字段指明的值。窗口大小表示接收端期望接收的字节数
校验和：覆盖整个TCP报文段
紧急指针：当URG标志为1时有效。是一个正的偏移量，和序号值相加表示紧急数据最后一个字节的序号
选项：
	MSS(Maximum Segment Size) 最长报文段大小，指明本端所能接收的最大长度的报文段
	
2、TCP连接的建立与终止

（1）连接建立 —— 三次握手
	C端发送，SYN + ISN(C)
	S端接收，并响应 SYN + ISN(S) + ACK(ISN(C)+1)
	C端接收，并响应 ISN(C) + ACK(ISN(S)+1)

（2）连接终止 —— 四次挥手
	TCP时全双工的，因此每个方向必须单独地进行关闭
	发送FIN来终止某个方向上的连接。发送FIN通常是应用层关闭的结果
	某一端发送SN + FIN，另一端响应ACK(SN+1)
	
（3）连接建立的超时
	大多数伯克利系统将建立一个新连接的最长时间限制为75s —— 发送SYN时的超时重传机制
	典型的伯克利实现版的系统将初始序号初始化为1，每隔0.5s就增加64000
	BSD版的TCP软件采用一种 500ms 的定时器。定时器初始化为12个时钟滴答，及6s的定时器。
		定时器会在设置后第一个0~500ms中任意时刻减1，当滴答计数为0，6s的定时器便会超时，这个定时器会在以后的24s重新复位
		
（4）最大报文端长度 —— 连接建立时通告
	MSS(Maximum Segment Size)表示TCP传往另一端的最大数据的长度
		连接建立的双方都要通告各自的MSS —— 发送SYN + MSS，响应SYN + MSS + ACK
	当TCP建立连接请求时，它会将MSS值设置为外出接口上的MTU长度减去固定的IP首部和TCP首部长度 —— 避免分段
	跨路由的MSS通常的默认值为536
	
（5）TCP的半关闭
	全双工，两个方向上传输，可以关闭任意方向上的连接
	用来通知对端，我的数据已经发送完了

（6）TCP的状态变迁
	TIME_WAIT状态
		也称为2MSL等待状态
		TCP实现必须选择一个报文段最大生存时间MSL(Maximum Segment Lifetime)
			报文段被丢弃前在网络内的最长时间
		RFC 793指出MSL为2分钟。实现中常用值为30s，1分钟或2分钟
	当TCP执行一个主动关闭，并发回最后一个ACK，该链连接必须在TIME_WAIT状态停留的时间为2倍MSL
		如果最后的ACK丢失，则此时TCP可以再次发送
		在TIME_WAIT状态，连接所占用的端口无法被其他应用使用，或重新分配给其他应用
	FIN_WAIT_2状态
		在主动关闭时，另一端可能忘记关闭连接，这样会导致一端一直保持FIN_WAIT_2状态，另一端一直处于CLOSE_WAIT状态
	
（7）复位报文段
	TCP以下情况使用复位报文段
		连接不存在的端口
		异常终止一个连接
			使用SO_LINGER可以实现API的异常关闭能力，即发送RST报文
		检测半打开连接
			半打开连接：一方已经关闭连接或异常终止连接，而另一方却不知道
			当未知的一方发送数据时，断开的一方响应复位报文
（8）同时打开
	双方同时发送SYN，这是只要双方再发送SYN+ACK，则连接建立，仍然是建立一条连接
	
（9）同时关闭
	双方同时发送FIN，进入FIN_WAIT，收到双方的FIN，进入CLOSED，发送ACK，收到双方的ACK进入TIME_WAIT
	
（10）TCP选项
	RFC 1323：定义了新的TCP选项

（11）TCP服务器设计
	连接请求队列
		已经建立连接的TCP放入等待队列
		应用层从队列中取出一个连接处理
		当连接队列满时，TCP将不会理会新的SYN

3、TCP的交互数据流
	交互数据分组通常都是比较小的
	Nagle算法可以减少通过广域网传输的小分组的数目

（1）延时发送 —— 数据捎带ACK
	一般实现采用时延200ms —— 等待200ms看是否有数据一起发送
		BSD版本的实现是固定每个200ms发送，接收的数据可能在0~200ms内任意时刻到达

（2）Nagle算法
	前提：TCP连接上最多只能有一个未被确认的未完成的小分组
		  该分组的确认达到之前不能发送其他的小分组 —— 如何定义这个 “小”
	TCP_NODELAY —— 关闭Nagle算法
	
（3）窗口大小通告


4、TCP的成块数据流
	滑动窗口协议 —— 加速数据传输
		不必阻塞等待一个分组的确认包
		在分组确认包到来之前可以连续发送多个分组
	慢启动

（1）滑动窗口
	滑动窗口就是通知目前的缓存大小
		当缓存数据被读取后，窗口会变大
		窗口外的数据包已经被ACK确认
		大多数实现每收到两个报文就发送一个ACK，而不必等待窗口被填满
（2）窗口大小
	接收方提供的窗口大小通常可以由进程控制
		实现表明，增大最大窗口大小可以提高吞吐量

5、PUSH标志
	通知接收方立即读取缓存以及带有PUSH标志这个报文
	
6、慢启动
	异构网络中，收发双方存在多个路由器和速率较慢的链路，
		如果一次性发送大量分组，则一些中间慢速路由器必须缓存分组，并有可能耗尽存储空间
	慢启动通过观察收发双方分组速率匹配而进行工作
	拥塞窗口：
		链路上的最大缓存
		发送方使用拥塞窗口和通告窗口中的最小值作为发送上限
		最初拥塞窗口为1，呈指数增长，达到阈值时变为阈值的一半
	
7、成块数据的吞吐量
	发送一分组的时间取决于两个因素：传播时延和发送时延
		传播时延与链路本身有关，给定两点间的传播时延基本固定
		发送时延与分组大小有关，分组越大，发送时延越大；也发送的速率有关，对于千兆比特率的发送设备，传播时延占据主要地位
		
8、紧急方式
	紧急方式用于一端告诉另一端“紧急数据”已经放置在普通的数据流中
		紧急啊方式只是发送方到接收方的通知
	通过设置URG比特位，同时设置16bit的紧急指针告诉接收方
	接收方接收到紧急数据后，只要紧急数据还有，那么应用就处于“紧急方式”



=============================
	  TCP的超时与重传
=============================

1、重传定时器
在定时范围内收到另一端的确认报文
	当重传多次依旧失败后，会发送复位信号


2、坚持定时器
使窗口大小信息保持不断流动，即使另一端关闭了其接收窗口


3、保活定时器
检测一个空闲连接的另一端何时崩溃或重启
	RFC提到实现保活功能
		保活应由应用程序指定
		保活间隔可配，默认值不能小于2小时


4、2MSL定时器测量一个连接处于TIME_WAIT状态的时间


=============================
	  TCP的未来和性能
=============================

MTU发现机制
流量控制 —— 发送窗口通知
拥塞避免 —— 拥塞窗口
超时重传

1、路径MTU发现。增加MTU
2、长肥管道。通过窗口扩大选项增加窗口
3、时间戳。通过时间戳计算RTT
4、T/TCP，事务TCP。避免连接建立和终止的开销
