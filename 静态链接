
预处理
编译：生成汇编语言代码 (cc)
汇编：生成机器代码 (as)
链接：解析外部符号引用 (ld)


1、编译
（1）词法分析 —— 有限状态机 (标识符, 关键字, 字面量, 特殊符号)
（2）语法分析 —— 上下文无关语法及下推自动机
	比如C语言的一个语句就是一个表达式
	复杂的语句由很多表达式组合而成
	
（3）语义分析 —— 静态语义分析
（4）代码生成

====================== x86 汇编基础 ==========================

汇编程序的基本组件：指令，伪指令，标号，注释

指令：CPU执行的实际操作
伪指令：汇编工具指令，告诉汇编工具生成特定数据，并将指令或数据放在指定的节(section)
标号：汇编工具中引用指令或数据的符号名称
注释：#

1、伪指令
（1）.section：告诉汇编工具将在哪个节放置后面的内容
（2）.string：表示ASCII字符串；.byte；.word；.long；.quad(8字节)
（3）.text：是 .section .text的简写

2、代码与数据分离

3、x86指令集

源操作数，目的操作数

（1）通用寄存器

累加器：rax，低32位 eax，低16位 ax，低字节 al，2字节 ah
基址寄存器：rbx，ebx，bx，bl，2字节 bh
计数器：rcx，ecx，cx，cl，ch
数据寄存器：rdx，edx，dx，dl，dh
栈寄存器：rsp，esp，sp，spl
基址指针：rbp，ebp，bp，bpl
源地址索引：rsi，esi，si，Sil
目的地址索引：rdi，edi，di，Dil
通用寄存器：r8~r15，r8d~r15d，r8w~r15w，r8l~r15l

4、常见的x86指令

（1）数据传输
mov dst, src		src赋值给dst
xchg dst1, dst2   	互换
push src			入栈，递减rsp
pop dst				出栈赋值给dst，递增rsp

（2）算术
add dst, src
sub dst, src
inc dst				dst += 1
dec dst				dst -= 1
neg dst				dst = -dst
cmp src1, src2 		根据src1 - src2设置状态标志位

（3）逻辑
and dst, src		dst &= src
or dst, src			dst |= src
xor dst, src 		dst ^= src
not dst 			dst = ~dst
test src1, src2		根据 src1 & src2 设置标志位

（4）无条件分支
jmp addr			跳转到地址
call addr 			压入返回地址到栈上，然后调用函数地址
ret					从栈上弹出返回地址，然后跳转到该地址
syscall 			进入内核执行系统调用
je addr / jz addr 	如果设置ZF零标志位则跳转
ja addr				上一次比较中，如果dst大于src则跳转(无符号)
jb addr 			上一次比较中，如果dst小于src则跳转
jg addr												  (有符号)
jl addr
jge addr
jle addr
js addr 			上一次比较中，如果结果为负则跳转

（5）其他
lea dst, src		将内存地址加载到dst中
nop					空指令，不执行操作

====================== x86 汇编基础 END ==========================




2、汇编

汇编代码翻译成机器指令

目标代码中的变量如果都在同一个编译单元，则编译器可以为它们分配空间，确定地址
目标代码中有变量在其他模块，如何确定他们的地址，如何分配空间？

========================= 目标文件 ===========================
使用 objdump 对目标文件进行反汇编, 可以查看目标文件的组成

Windows下的PE(Protable Executable)和Linux下的ELF(Executable Linkable Format)都是COFF(Common file format, 引入了"段"的概念)格式的变种

可执行文件，动态链接库，静态链接库都是按照可执行文件格式存储的

Section/Segment
	代码段：.code/.text
	数据段：.data
	注释信息段：.comment
	只读数据段：.rodata
	堆栈提示段：.note.GNU-stack
	.bss段：存放未初始化的全局变量和局部静态变量所占用的字节数
	.eh_frame
	
		读写分离 —— 只读, 读写
		高速缓存 —— 缓存命中率
		共享指令
	
（1）可执行文件
文件头：描述文件属性
	包括是否可执行
	是静态库还是动态库及入口地址(可执行文件)
	目标硬件
	目标操作系统
	段表(描述文件中各个段的数组)
	
（2）objdump分析目标文件

objdump -h, 显示目标文件的各个段信息(可能是读取段表)
objdump -s, 将段的内容以十六进制的方式打印出来
objdump -d, 将所有包含指令的段反汇编

__attribute__((section("xxx"))) int global = 42; //指定放到xxx段

（3）ELF文件结构描述

readelf -h, 查看elf文件的文件头
readelf -S, 查看elf文件头中的段表
	.rel.text段：重定位段表，记录需要重定位的
readelf -s, 查看符号表, 符号的值即为符号的地址
	
========================= 目标文件 END ===========================

3、链接器

用符号来表示地址 —— 符号来表示地址

链接：将各个模块之间相互引用的部分正确地衔接起来
		确定地址
		确定空间
		确定符号
		重定位 —— 找到符号在哪个模块定，修正所有引用该符号的模块中的符号地址(未确定地址前, 地址值未0x00)
		
链接的接口 —— 符号

（1）链接中的特殊符号

链接脚本中定义了一些特殊符号，用来进行链接控制，可以在程序中直接声明并使用

	extern char __executable_start[];
	printf("Executable Start %X", __executable_start);

__executable_start, 程序起始地址, 程序最开始的地址
__etext/_etext/etext, 代码段结束地址
_edata/edata, 数据段结束地址
_end/end, 程序结束地址

（2）extern "C"

C++为了与C兼容
C++编译器会将在 extern "C" 的大括号内部的代码当作C语言代码处理
C++编译器会默认定义 __cplusplus 宏, 可以使用这个宏来控制代码是否需要声明成 extern "C"

（3）弱符号和弱引用

对于库很有用
	库中定义的弱符号可以被用户定义的强符号所覆盖
	用户声明一个弱引用, 如果链接的库中定义了这个接口, 则调用(即判断这个接口是否为空, 不为空则定义了)
	
（4）调试信息
-g参数，目标文件中会多出很多 debug 相关的段




4、静态链接


（1）空间和地址分配

多个目标文件 —— 相似段合并
分配虚拟地址

	ld a.o b.o -e main -o ab
		-e main, 将main作为程序入口
	链接前目标文件的素有段的虚拟地址都是0, 因为此时虚拟空间还没有分配
	链接后可执行文件中的各个段都分配了响应的虚拟地址 —— 动态链接库怎么办？

（2）符号解析和重定位

objdump -r, 查看目标文件的重定位表

重定位表
	保存和重定位相关的信息
	objdump -r, 查看目标文件的重定位表, 确定符号的在某个段的偏移
	objdump -d, 查看目标文件的反汇编, 可以根据重定位表的偏移看到外部符号在反汇编中的地址

如何查看符号在本文件中的偏移
	

（3）COMMON块

弱符号占用的空间大小未知

如果存在同名的符号，使用占用空间最大的哪个


（4）C++相关问题

重复代码消除 —— 模板，外部内联函数，虚函数表
全局构造与析构
C++ABI

（5）静态库链接

静态库，一组目标文件的集合。
	libc中目标文件中都是单个函数，是因为链接是以目标文件为输入，避免未使用的函数也被链接上


（6）链接过程控制

（7）BFD库


5 Windows PE/COFF

PE，Windows可执行文件格式
COFF，Visual C++编译器产生的目标文件格式

GCC中使用扩展属性 __attribute__((section("name")))，指定段名
Visual C++使用 #pragma 编译器指示段名
