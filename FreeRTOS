
===========================================
				FreeRTOS特点
===========================================
实施质量管理
	1、从不在临界区或中断内部执行非确定性操作，例如，遍历链接列表
	2、高效的软件定时器 —— 不使用任何CPU时间，不包含需要倒计时到零的变量
	3、阻塞(挂起)任务列表同样也不需要耗时的定期维护
	4、直达任务通知 —— 允许快速的任务信号发送，几乎没有RAM开销，并且可用于大多数的任务间以及中断到任务的信号发送情景
	5、FreeRTOS队列使用模型兼容简单性和灵活性
	6、FreeRTOS队列是基础原语，其他通信和同步原语都在其上构建

RTOS技术亮点
	1、抢占式调度选项
	2、协作式调度选项
	3、任务通知快速
	4、部分移植从不完全禁用中断
	
	1、消息传递易于使用
	2、带时间切片的轮询调度
	3、互斥锁采用优先级继承机制
	4、递归互斥
	5、二进制和计数信号量
	6、软件定时器极其高效
	7、API易于使用
	

===========================================
			FreeRTOS开发者文档
===========================================

调度器
队列，互斥锁，信号量，递归互斥
直达任务通知
流&消息缓冲区
软件定时器
内存管理 —— 静态内存，动态内存，堆栈溢出保护

1、调度器

（1）任务
任务状态：运行，就绪，阻塞，挂起
任务优先级：

（2）处理器架构
单核：
AMP：非对称多核。每个核心运行一个FreeRTOS实例，多核可以异构，即相互独立，核心之间可以通过共享内存通信
SMP：简单多处理器(对称多核)。同构通过，一个FreeRTOS实例调度多个处理器核心

（3）调度算法
单核：固定优先级的抢占式调度策略，同等优先级任务执行时间片轮询调度
	固定优先级：调度器不更改任务的优先级
	抢占式：调度器始终运行优先级最高且可运行的RTOS任务
	轮询：相同优先级的任务轮流进入运行状态
	时间片：调度器会在每个tick中断上在同等优先级任务之间进行切换
			tick中断之间构成一个时间片
			tick中断是RTOS用来衡量时间的周期性中断
AMP：每个核心运行单核的调度算法
SMP：多个处理器可能运行不同优先级的任务，但是高优先级且可运行任务依然全局优先	
	

2、队列，信号量，互斥锁，递归互斥锁

（1）队列
多用于任务间或中断与任务间进行通信

（2）二进制信号量
数值为1的信号量，只有0和1两种状态，多用于同步

（3）计数信号量
	盘点事件
		时间发生时，信号量递增；事件处理完毕，信号量递减
	资源管理
		计数值表示可用资源的数量。获得资源则递减信号量；释放资源则递增信号量
		
（4）互斥锁
保护资源，同一时刻只能有一个任务访问该资源
存在优先级继承机制：
	如果高优先级任务在尝试获取当前由较低优先级任务持有的互斥锁时阻塞
	则持有互斥锁的任务的优先级会暂时提高到阻塞任务的优先级
	使得较高优先级的任务保持阻塞状态的时间尽可能短

（5）递归互斥锁
可对一把互斥锁重复加锁，但是解锁次数要和加锁次数匹配，互斥锁才能继续使用

3、直达任务通知
每个RTOS任务都有一个任务通知数组
	每条任务通知都有 ”挂起“ 或 ”非挂起“ 通知状态，以及一个32位的通知值
	
直达任务通知可以用来实现同步和互斥，且效率比通过中间对象（队列，事件组，信号量）要高
	直达任务通知存在诸多限制
	
4、流缓冲区&消息缓冲区

流缓冲区是RTOS任务到RTOS任务，以及中断到任务的通信原语

流缓冲区
	可以读取或写入任意字节的数据流

消息缓冲区
	基于流缓冲区实现
	只能读取或写入具体消息的大小

5、软件定时器

定时器服务
	定时器任务队列中接收应用程序发送过来任务进行执行

6、事件组（或“标志”）


7、静态内存 VS 动态内存

（1）动态分配RTOS对象的好处
	创建对象时所需的函数参数较少
	内存分配在RTOS API函数内自动发生
	应用程序写入器无需担心它们自己分配的内存
	RAM对象被删除，它所使用的RTOS可以重新被使用，从而可能减少应用程序的最大RAM占用
	提供RTOS API函数以返回关于堆使用的信息，从而允许优化堆大小
	最大限度地减少使用应用程序的最大RAM
	
（2）静态内存
	RTOS对象可以放置在特定的内存位置
	最大RAM占用可以在链接时间确定
	应用程序写入器可以很好地处理内存分配故障
	在该类应用程序中不允许任何动态内存分配

8、堆内存管理

FreeRTOS包含了五个内存分配示例

	heap_1.c：不允许释放内存
	heap_2.c：允许释放内存，但是不会合并相邻的空闲块
	heap_3.c：见到那包装malloc()和free()，以保证线程安全
	heap_4.c：合并相邻的空闲块以避免碎片化。包含绝对地址放置选项
	heap_5.c：如同heap_4.c，能够跨越多个不相邻内存区域的堆
	
9、堆栈溢出保护

使用堆栈溢出钩子函数

堆栈溢出检测方法1
	RTOS内核使任务退出运行状态后，堆栈可能达到最大值(最深值)，因为此时的堆栈会包含上下文
	此时RTOS内核可以检查处理器堆栈指针是否仍在有效堆栈空间内。如果堆栈指针包含超出有效堆栈范围的值，则调用钩子函数
	
堆栈溢出检测方法2
	任务首次创建时，其堆栈会填充一个已知值
	任务退出运行状态时，RTOS内核可以检查有效堆栈范围内的最后16个字节，以确保这些已知值未被任务或中断活动覆盖
	如果这 16 个字节中的任何一个不再为初始值，则调用堆栈溢出钩子函数

（1）内存保护

MPU内存保护单元
	MPU 移植首先能够使任务能够在特权模式或非特权模式下运行，
	然后限制对 RAM、可执行代码、外围设备和超出任务堆栈限制的内存等资源的访问，
	从而使微控制器应用程序更加强大和安全



===========================================
			FreeRTOS API简介
===========================================

任务创建
任务控制
任务实用程序
RTOS内核控制
直达任务通知
队列
队列集
流缓冲区
消息缓冲区
信号量/互斥量
软件定时器
事件组


	
	
	
	
	

===========================================
				RTOS基本概念
===========================================
1、基本概念
实时系统
	及时的对事件做出响应
		事件发生存在“截止时间”，截止时间之前要做出响应
		
多任务切换
	通过任务间快速切换实现多任务系统
	上下文切换
		上下文：任务执行时的处理器，寄存器，堆栈信息
		切换：保存切出去的任务上下文；恢复切进来的任务上下文

调度策略
	任务挂起
		被动挂起：调度器决定在任务时间点执行哪个任务
		自动挂起：睡眠；等待资源
		唤醒：将处于休眠状态的任务就绪执行
			  何时唤醒？
	任务优先级
		高优先级抢占低优先级的CPU时间
		同等优先级“公平”享用CPU时间

2、FreeRTOS时钟调度实现
FreeRTOS时钟调度的在Atmel AVR上的实现
	1、使用硬件定时器的中断完成
	2、ISR(Interrupt Service Routine)执行调度器
		//signal属性告诉编译器这是个ISR
		//			ISR —— 进入时保存处理器寄存器的值，退出时恢复
		//					进入ISR时禁用中断，退出时重新启用中断
		//naked属性防止编译器生成任何函数入口或出口代码 —— 即不会添加保存上文和恢复上下文的代码，需要显式地在程序中保存/恢复上下文
		void SIG_OUTPUT_COMPARE1A(void) __attribute__((signal, naked));
		void vPortYieldFromTick(void) __attribute__((naked));  //存储上下文，执行调度，恢复上下文

		void SIG_OUTPUT_COMPARE1A(void)
		{
			vPortYieldFromTick();
			
			asm volatile("reti");
		}

		void vPortYieldFromTick(void)
		{
			portSAVE_CONTEXT();
			
			vTaskIncrementTick();
			
			vTaskSwitchContext();
			
			portRESTORE_CONTEXT();
			
			asm volatile("ret");
		}
	3、高优先级抢占低优先级CPU时间
	4、AVR上下文
		通用寄存器
		状态寄存器
		程序计数器
		堆栈指针寄存器
	
	
